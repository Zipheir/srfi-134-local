<html>
  <head>
    <title>SRFI 134: Immutable Deques</title>
    <link rel="stylesheet" href="http://srfi.schemers.org/srfi.css" type="text/css" />
  </head>

  <body>

<h1>Title</h1>

Immutable Deques

<h1>Author</h1>

Kevin Wortman, John Cowan

<h1>Abstract</h1>

<p>
This SRFI defines immutable deques. A deque is a double-ended queue, a sequence which allows elements to be added or removed efficiently from either end.  A structure is immutable when all its operations leave the structure unchanged. Note that none of the procedures specified here ends with an exclamation point.</p>

<h1>Issues</h1>

None at this time.

<h1>Rationale</h1>

<p>
A double-ended queue, or <em>deque</em> (pronounced "deck") is a sequential data structure which allows elements to be added or removed from either end in O(1) time.  It is a generalization of both a queue and a stack, and can be used as either by disregarding the irrelevant procedures.  
</p>
<p>
This SRFI describes immutable deques, or <em>ideques</em>.  Immutable structures are sometimes called <em>persistent</em> and are closely related to <em>pure functional</em> (a.k.a. <em>pure</em>) structures. The availability of immutable data structures facilitates writing efficient programs in the pure-functional style.  Unlike the immutable lists of <a href="http://srfi.schemers.org/srfi-116/srfi-116.html">SRFI 116</a>, it is efficient to produce modified versions of an ideque; unlike the list queues of <a class="ext-link" href="http://srfi.schemers.org/srfi-117/srfi-117.html">SRFI 117</a>, it is possible to efficiently return an updated version of an ideque without mutating any earlier versions of it.
</p>
<p>
The specification was designed jointly by Kevin Wortman and John Cowan.  John Cowan is the editor and shepherd.  The sample implementation was written by ???.</p>

<h1>Specification</h1>

<p>
We specify required time efficiency upper bounds using big-O notation. We note when, in some cases, there is "slack" between the required bound and the theoretically optimal bound for an operation. Implementations may use data structures with amortized time bounds, but should document which bounds hold in only an amortized sense. The use of randomized data structures with expected time bounds is discouraged.
</p>
<p>
Deques are disjoint from all other Scheme types.
</p>
<h2 id="Constructors">Constructors</h2>
<p>
<tt>(ideque </tt>[ <em>element</em> ...]<tt>)</tt>
</p>
<p>
Returns an ideque containing the <em>elements</em>. The leftmost element (if any) will be at the front of the ideque and the rightmost element (if any) will be at the back. Takes O(n) time, where <em>n</em> is the number of elements.
</p>
<p>
<tt>(ideque-unfold </tt><em>stop? mapper successor seed</em><tt>)</tt>
</p>
<p>
Invokes the predicate <em>stop?</em> on <em>seed</em>.  If it returns false, generate the next result by applying <em>mapper</em> to <em>seed</em>, generate the next seed by applying <em>successor</em> to <em>seed</em>, and repeat this algorithm with the new seed.  If <em>stop?</em> returns true, return an ideque containing the results in order of accumulation.  Takes O(n) time.
</p>
<p>
<tt>(ideque-unfold-right </tt><em>stop? mapper successor seed</em><tt>)</tt>
</p>
<p>
Invokes the predicate <em>stop?</em> on <em>seed</em>.  If it returns false, generate the next result by applying <em>mapper</em> to <em>seed</em>, generate the next seed by applying <em>successor</em> to <em>seed</em>, and repeat the algorithm with the new seed.  If <em>stop?</em> returns true, returnan idequee containing the results in reverse order of accumulation.  Takes O(n) time.
</p>
<h2 id="Predicates">Predicates</h2>
<p>
<tt>(ideque? </tt><em>x</em><tt>)</tt>
</p>
<p>
Returns <tt>#t</tt> if <em>x</em> is an ideque, and <tt>#f</tt> otherwise.  Takes O(1) time.
</p>
<p>
<tt>(ideque-empty? </tt><em>ideque</em><tt>)</tt>
</p>
<p>
Returns <tt>#t</tt> if <em>ideque</em> contains zero elements, and <tt>#f</tt> otherwise.  Takes O(1) time.
</p>
<h2 id="Queueoperations">Queue operations</h2>
<p>
<tt>(ideque-front </tt><em>ideque</em><tt>)</tt>
</p>
<p>
<tt>(ideque-back </tt><em>ideque</em><tt>)</tt>
</p>
<p>
Returns the front/back element of <em>ideque</em>. It is an error for <em>ideque</em> to be empty. Takes O(1) time.
</p>
<p>
<tt>(ideque-remove-front </tt><em>ideque</em><tt>)</tt>
</p>
<p>
<tt>(ideque-remove-back </tt><em>ideque</em><tt>)</tt>
</p>
<p>
Returns an ideque with the front/back element of <em>ideque</em> removed. It is an error for <em>ideque</em> to be empty. Takes O(1) time.
</p>
<p>
<tt>(ideque-add-front </tt><em>ideque obj</em><tt>)</tt>
</p>
<p>
<tt>(ideque-add-back </tt><em>ideque obj</em><tt>)</tt>
</p>
<p>
Returns an ideque with <em>obj</em> pushed to the front/back of <em>ideque</em>. Takes O(1) time.
</p>
<h2 id="Otheraccessors">Other accessors</h2>
<p>
<tt>(ideque-take </tt><em>ideque n</em><tt>)</tt>
</p>
<p>
<tt>(ideque-take-right </tt><em>ideque n</em><tt>)</tt>
</p>
<p>
Returns an ideque containing the first/last <em>n</em> elements of <em>ideque</em>.  Takes O(n) time.
</p>
<p>
<tt>(ideque-drop </tt><em>ideque n</em><tt>)</tt>
</p>
<p>
<tt>(ideque-drop-right </tt><em>ideque n</em><tt>)</tt>
</p>
<p>
Returns an ideque containing all but the first/last <em>n</em> elements of <em>ideque</em>.  Takes O(n) time.
</p>
<p>
<tt>(ideque-split-at </tt><em>ideque n</em><tt>)</tt>
</p>
<p>
Returns two values, the results of <tt>(ideque-take </tt><em>ideque n</em><tt>)</tt> and <tt>(ideque-drop </tt><em>ideque n</em><tt>)</tt> respectively, but may be more efficient.  Takes O(n) time.
</p>
<h2 id="Thewholedeque">The whole ideque</h2>
<p>
<tt>(ideque-length </tt><em>ideque</em><tt>)</tt>
</p>
<p>
Returns the length of <em>ideque</em> as an exact integer.  May take O(n) time, though O(1) is optimal.
</p>
<p>
<tt>(ideque-append </tt><em>ideque</em> ...<tt>)</tt>
</p>
<p>
Returns an ideque with the contents of the <em>ideque</em> followed by the others, or an empty ideque if there are none. Takes O(kn) time, where k is the number of ideques and n is the number of elements involved, though O(k log n) is possible.
</p>
<p>
<tt>(ideque-concatenate </tt><em>list-of-ideques</em><tt>)</tt>
</p>
<p>
Returns an ideque with the contents of the first ideque in <em>list-of-ideques</em> followed by the others. This is provided for Schemes in which the number of arguments which can be passed to <tt>apply</tt> is limited.  Takes O(kn) time, where k is the number of ideques and n is the number of elements involved, though O(k log n) is possible.
</p>
<p>
<tt>(ideque-reverse </tt><em>ideque</em><tt>)</tt>
</p>
<p>
Returns an ideque containing the elements of <em>ideque</em> in reverse order.  Takes O(n) time.
</p>
<p>
<tt>(ideque-count </tt><em>pred ideque</em><tt>)</tt>
</p>
<p>
Returns the number of elements of <em>ideque</em> which satisfy <em>pred</em> as an exact integer.  Takes O(n) time.
</p>
<p>
<tt>(ideque-zip </tt><em>ideque</em> ...<tt>)</tt>
</p>
<p>
Returns an ideque of lists (not ideques) each of which contains the corresponding elements of the argument ideques in the order specified.  Processing stops when all the elements of any ideque have been seen. Takes O(kn) time, where <em>k</em> is the number of ideques and <em>n</em> is the number of elements involved.
</p>
<h2 id="Mapping">Mapping</h2>
<p>
<tt>(ideque-map </tt><em>proc ideque</em> ...<tt>)</tt>
</p>
<p>
Applies <em>proc</em> to the corresponding elements of <em>ideques</em> and returns an ideque containing the results in order.  Terminates when any ideque is finished.  Takes O(n) time.
</p>
<p>
<tt>(ideque-for-each </tt><em>proc ideque</em> ...<tt>)</tt>
</p>
<p>
Applies <em>proc</em> to the corresponding elements of <em>ideques</em> in order and returns an unspecified result.  Terminates when any ideque is finished.  Takes O(n) time.
</p>
<p>
<tt>(ideque-fold </tt><em>proc nil ideque</em> ...<tt>)</tt>
</p>
<p>
<tt>(ideque-fold-right </tt><em>proc nil ideque</em> ...<tt>)</tt>
</p>
<p>
Invokes <em>proc</em> on the corresponding elements of <em>ideques</em> in forward/reverse order, passing the result of the previous invocation as a second argument. For the first invocation, <em>nil</em> is used as the second argument. Returns the result of the last invocation, or <em>nil</em> if there was no invocation.  Terminates when any ideque is finished.  Takes O(n) time.
</p>
<p>
<tt>(ideque-append-map </tt><em>proc ideque</em> ...<tt>)</tt>
</p>
<p>
Applies <em>proc</em> to the corresponding elements of <em>ideques</em>.  It is an error if the result is not a list.  Returns an ideque containing the elements of the lists in order.  Terminates when any ideque is finished.  Takes O(n) time.
</p>
<h2 id="Filtering">Filtering</h2>
<p>
<tt>(ideque-filter </tt><em>pred ideque</em><tt>)</tt>
</p>
<p>
<tt>(ideque-remove </tt><em>pred ideque</em><tt>)</tt>
</p>
<p>
Returns an ideque which contains the elements of <em>ideque</em> that do/do not satisfy <em>pred</em>.  Takes O(n) time.
</p>
<p>
<tt>(ideque-partition </tt><em>proc ideque</em><tt>)</tt>
</p>
<p>
Returns two values, the results of <tt>(ideque-filter </tt><em>pred ideque</em><tt>)</tt> and <tt>(ideque-remove </tt><em>pred ideque</em><tt>)</tt> respectively, but may be more efficient.  Takes O(n) time.
</p>
<h2 id="Searching">Searching</h2>
<p>
<tt>(ideque-find </tt><em>pred ideque failure</em><tt>)</tt>
</p>
<p>
<tt>(ideque-find-right </tt><em>pred ideque failure</em><tt>)</tt>
</p>
<p>
Returns the first/last element of <em>ideque</em> that satisfies <em>pred</em>.  If there is no such element, returns the result of invoking the thunk <em>failure</em> .  Takes O(n) time.
</p>
<p>
<tt>(ideque-take-while </tt><em>pred ideque</em><tt>)</tt>
</p>
<p>
<tt>(ideque-take-while-right </tt><em>pred ideque</em><tt>)</tt>
</p>
<p>
Returns an ideque containing the longest initial/final prefix of elements in <em>ideque</em> all of which satisfy <em>pred</em>.  Takes O(n) time.
</p>
<p>
<tt>(ideque-drop-while </tt><em>pred ideque</em><tt>)</tt>
</p>
<p>
<tt>(ideque-drop-while-right </tt><em>pred ideque</em><tt>)</tt>
</p>
<p>
Returns an ideque which omits the longest initial/final prefix of elements in <em>ideque</em> all of which satisfy <em>pred</em>, but includes all other elements of <em>ideque</em>.  Takes O(n) time.
</p>
<p>
<tt>(ideque-span </tt><em>pred ideque</em><tt>)</tt>
</p>
<p>
<tt>(ideque-break </tt><em>pred ideque</em><tt>)</tt>
</p>
<p>
Returns two values, the initial prefix of the elements of <em>ideque</em> which do/do not satisfy <em>pred</em>, and the remaining elements.  Takes O(n) time.
</p>
<p>
<tt>(ideque-any </tt><em>pred ideque</em><tt>)</tt>
</p>
<p>
<tt>(ideque-every </tt><em>pred ideque</em><tt>)</tt>
</p>
<p>
Invokes <em>pred</em> on the elements of <em>ideque</em> in order until one of them returns a true/false value, which is then returned.  If there are no such elements, returns <tt>#f</tt>/<tt>#t</tt>.  Takes O(n) time.
</p>
<h2 id="Conversion">Conversion</h2>
<p>
<tt>(list-&gt;ideque </tt><em>list</em><tt>)</tt>
</p>
<p>
<tt>(ideque-&gt;list </tt><em>ideque</em><tt>)</tt>
</p>
<p>
Conversion between ideque and list structures. FIFO order is preserved, so the front of a list corresponds to the front of an ideque. Each operation takes O(n) time.
</p>
<p>
<tt>(generator-&gt;ideque </tt><em>generator</em>`)
</p>
<p>
<tt>(ideque-&gt;generator </tt><em>ideque</em><tt>)</tt>
</p>
<p>
Converts a <a href="http://srfi.schemers.org/srfi-121/srfi-121.html"><SRFI 121</a> generator to and from an ideque.
</p>

<h1>Implementation</h1>

The sample implementation is (not yet) in the repository for this SRFI.

<h1>Copyright</h1>
Copyright (C) John Cowan, Kevin Wortman (2015).  All Rights Reserved. 

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:</p>

<p>
  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.</p>

<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.</p>

  <hr />
  <address>Editor: <a href="mailto:srfi-editors at srfi dot schemers dot org">Arthur A. Gleckler</a></address></body></html>
